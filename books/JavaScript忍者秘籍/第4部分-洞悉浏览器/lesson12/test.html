<!DOCTYPE html><html lang="en"><head>  <meta charset="UTF-8">  <title>Title</title></head><body><div id="samurai"></div><div id="element" style="border-width: 1px; border-style: solid; border-color: red"></div><script>  {    /**     * test 1     * 断言全部通过     *     * 只要 element 属性不是自定义属性, 则与特性相同     */    const element = document.querySelector('#samurai')    console.log(element.id === 'samurai')    console.log(element.getAttribute('id') === 'samurai')    element.id = 'newSamurai'    console.log(element.id === 'newSamurai')    console.log(element.getAttribute('id') === 'newSamurai')  }  {    /**     * test 2     * 如何访问 border-width 样式属性     */    const element = document.querySelector('#element')    const borderWidth1 = element.style['border-width']    const borderWidth2 = window.getComputedStyle(element).getPropertyValue('border-width')    const borderWidth3 = element.style.borderWidth    console.log(borderWidth1)    console.log(borderWidth2)    console.log(borderWidth3)  }  {    /**     * test 3     * 哪些内置方法可以获取应用于指定元素上的所有样式     *     * getComputedStyle     */  }  {    /**     * test4     *     * 什么时候发生布局抖动?     * 当对 DOM 进行一系列连续的读取和设置操作时, 浏览器每次都会强制重新计算布局信息, 这种常称为 页面回流(导致 DOM Tree 重新生成和计算DOM空间几何位置)     *     * 如何避免:     *  1. 设置也提供了第三方库, 如 fastDom     *  2. 进行批量的 DOM 属性获取和批量的设置, 这样经过浏览器的缓存队列优化, 最终只会发生一次回流     *  3. 使用 Vue 或 React 这些成熟的框架, 他们采用创新的虚拟 DOM 的批处理方式, 提高应用程序的性能     */  }</script></body></html>